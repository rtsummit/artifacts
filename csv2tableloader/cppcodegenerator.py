
import os
import shutil
import filecmp

from templatemanager import TemplateManager

from csvloader.csvtable import CSVTable, CSVColumn
from csvloader.csvtype import CSVTypeId, CSVType
from util import *

class CPPCodeGenerator_ItemType:
    def __init__(self, output_path, table):
        self._output_path = output_path
        self._table = table

    def prologue(self):
        self._output_h = open('ItemDataTable_Global.h', 'w')

    def epilogue(self):
        self._output_h.close()

        if 0 < len(self._output_path):
            h_file_name = 'ItemDataTable_Global.h'

            if False == file_compare(h_file_name, self._output_path):
                file_move(h_file_name, self._output_path)
                print('copied !')

    def generate(self):
        key_index = 0
        name_index = 1

        self._output_h.write('#pragma once\n\n')
        self._output_h.write('namespace Ares::Shop {\n')
        self._output_h.write('\tenum ItemType {\n')

        records = self._table.records()
        for record in records:
            self._output_h.write(f'\t\tItemType_{record[name_index]} = {record[key_index]}, \n')

        self._output_h.write('\t};\n')
        self._output_h.write('}\n')

class CPPCodeGenerator_UnlockType:
    def __init__(self, output_path, table):
        self._output_path = output_path
        self._table = table

    def prologue(self):
        self._output_h = open('UnlockContentsTable_Global.h', 'w')

    def epilogue(self):
        self._output_h.close()

        if 0 < len(self._output_path):
            h_file_name = 'UnlockContentsTable_Global.h'

            if False == file_compare(h_file_name, self._output_path):
                file_move(h_file_name, self._output_path)
                print('copied !')

    def generate(self):
        key_index = 0
        name_index = 1
        unlockNote_Index = 2

        self._output_h.write('// Copyright 2019-2021 SecondDive Corporation\n\n')
        self._output_h.write('// Generated by the Ares CSV2TableLoader.\n')
        self._output_h.write('// !!! DO NOT EDIT !!!\n\n')
        self._output_h.write('#pragma once\n\n')
        self._output_h.write('namespace Ares::Game {\n')
        self._output_h.write('enum class UnlockContentsType : unsigned int {\n')

        self._output_h.write(f'  NONE = 0, // Generated CSV2TableLoader\n')

        records = self._table.records()
        for record in records:
            self._output_h.write(f'  {record[name_index]} = {record[key_index]}, // {record[unlockNote_Index]}\n')

        self._output_h.write('};\n')
        self._output_h.write('}\n')

class CPPCodeGenerator:
    def __init__(self, output_path, table):
        self._output_path = output_path
        self._table = table
        self._message_name = self.to_message_name(self._table.name())
        self._class_name = 'CSV_' + self._message_name + 'Table'

    def prologue(self):
        self._output_h = open(f'{self._class_name}.h', 'w')
        self._output_cpp = open(f'{self._class_name}.cpp', 'w')

    def epilogue(self):
        self._output_h.close()
        self._output_cpp.close()

        if 0 < len(self._output_path):
            h_file_name = f'{self._class_name}.h'
            cpp_file_name = f'{self._class_name}.cpp'

            if False == file_compare(h_file_name, self._output_path) or False == file_compare(cpp_file_name, self._output_path):
                file_move(h_file_name, self._output_path)
                file_move(cpp_file_name, self._output_path)
                print('copied !')

    def generate(self):
        has_key_column = self._table.has_key_column()
        key_column_name = self._table.key_column_name()

        self._output_h.write(TemplateManager.get_cpp_h_template(has_key_column).format(
            className=self._class_name, 
            messageName=self._message_name, 
            keyType=self.csvtype_to_cpptype(self._table.key_column_type_id())
        ))

        csv_columns_to_proto_fields = ''
        i = 0
        for column in self._table.header():
            csv_columns_to_proto_fields += self.csv_column_to_proto_field(column, i)
            i += 1

        call_proto_key_field = f'ctx->{self.to_message_field_name(key_column_name)}()' if has_key_column else ''

        self._output_cpp.write(TemplateManager.get_cpp_cpp_template(has_key_column).format(
            className=self._class_name, 
            messageName=self._message_name, 
            keyType=self.csvtype_to_cpptype(self._table.key_column_type_id()), 
            fileName= self._table.file_name() if '.seg.csv' not in self._table.file_name() else self._table.name() + '.csv', 
            tableName=self._table.name(), 
            csvColumnsToProtoFields=csv_columns_to_proto_fields, 
            callProtoKeyField=call_proto_key_field
        ))

    def to_message_name(self, name):
        tokens = name.split('_')

        name = ''
        for token in tokens:
            name += token[0].upper() + token[1:]

        return name

    def to_message_field_name(self, name):
        return name.replace('_', '').lower()

    def csvtype_to_cpptype(self, type_id):
        if type_id == CSVTypeId.BOOL:
            return 'bool'
        elif type_id == CSVTypeId.INT:
            return 'int32_t'
        elif type_id == CSVTypeId.UINT:
            return 'uint32_t'
        elif type_id == CSVTypeId.ULONG:
            return 'uint64_t'
        elif type_id == CSVTypeId.FLOAT:
            return 'float'
        elif type_id == CSVTypeId.STRING:
            return 'std::string'
        elif type_id == CSVTypeId.TIME:
            return 'uint32_t'
        elif type_id == CSVTypeId.VECTOR3:
            return 'vector3'

        return 'uint32_t'

    def csv_column_to_proto_field(self, column, i):
        tabs = '\t\t' if 0 < i else ''

        if column.is_comment():
            return f'{tabs}// ignore column {column.name()}\n'

        if False == column.valid_name():
            return ''

        code = ''
        if column.type().is_vector():
            type_id = column.type().inner_type_id()
            type_name = self.csvtype_to_cpptype(type_id)

            code = f'{tabs}if (row.size() >= {i} + 1)\n'
            code += f'{tabs}{{\n'
            code += f'{tabs}\tstd::vector<std::string> parts;\n'
            code += f'{tabs}\tUtil::Split(row[{i}], "|", parts);\n'
            code += f'{tabs}\tfor (const auto& part : parts)\n'
            code += f'{tabs}\t{{\n'

            if CSVTypeId.BOOL == type_id:
                code += f'{tabs}\t\tctx->mutable_{self.to_message_field_name(column.name())}()->Add(0 < atoi(part.c_str()) ? true : false);\n'
            elif CSVTypeId.INT == type_id or CSVTypeId.UINT == type_id:
                code += f'{tabs}\t\tctx->mutable_{self.to_message_field_name(column.name())}()->Add(({type_name}) atoi(part.c_str()));\n'
            elif CSVTypeId.ULONG == type_id:
                code += f'{tabs}\t\tctx->mutable_{self.to_message_field_name(column.name())}()->Add(({type_name}) _atoi64(part.c_str()));\n'
            elif CSVTypeId.TIME == type_id:
                code += f'{tabs}\t\tctx->mutable_{self.to_message_field_name(column.name())}()->Add(({type_name}) Util::TimeUtil::StringToUnitTime(part.c_str()));\n'
            elif CSVTypeId.FLOAT == type_id:
                code += f'{tabs}\t\tctx->mutable_{self.to_message_field_name(column.name())}()->Add(({type_name}) atof(part.c_str()));\n'
            elif CSVTypeId.STRING == type_id:
                code += f'{tabs}\t\t*(ctx->mutable_{self.to_message_field_name(column.name())}()->Add()) = part;\n'
            elif CSVTypeId.VECTOR3 == type_id:
                code += f'{tabs}\t\tStringToVector3(part.c_str(), ctx->mutable_{self.to_message_field_name(column.name())}());\n'
            else:
                code = f'{tabs}// NOT IMPLEMENTED\n'

            code += f'{tabs}\t}}\n'
            code += f'{tabs}}}\n'
        else:
            type_id = column.type().type_id()
            type_name = self.csvtype_to_cpptype(type_id)

            if CSVTypeId.BOOL == type_id:
                code = f'{tabs}ctx->set_{self.to_message_field_name(column.name())}((row.size() >= {i}+1) ? (0 < atoi(row[{i}].c_str()) ? true : false) : false);\n'
            elif CSVTypeId.INT == type_id or CSVTypeId.UINT == type_id:
                code = f'{tabs}ctx->set_{self.to_message_field_name(column.name())}((row.size() >= {i}+1) ? ({type_name}) atoi(row[{i}].c_str()) : ({type_name}) 0);\n'
            elif CSVTypeId.ULONG == type_id:
                code = f'{tabs}ctx->set_{self.to_message_field_name(column.name())}((row.size() >= {i}+1) ? ({type_name}) _atoi64(row[{i}].c_str()) : ({type_name}) 0);\n'
            elif CSVTypeId.TIME == type_id:
                code = f'{tabs}ctx->set_{self.to_message_field_name(column.name())}((row.size() >= {i}+1) ? ({type_name}) Util::TimeUtil::StringToUnitTime(row[{i}].c_str()) : ({type_name}) 0);\n'
            elif CSVTypeId.FLOAT == type_id:
                code = f'{tabs}ctx->set_{self.to_message_field_name(column.name())}((row.size() >= {i}+1) ? ({type_name}) atof(row[{i}].c_str()) : 0.0f);\n'
            elif CSVTypeId.STRING == type_id:
                code = f'{tabs}ctx->set_{self.to_message_field_name(column.name())}((row.size() >= {i}+1) ? row[{i}] : "");\n'
            elif CSVTypeId.VECTOR3 == type_id:
                code = f'{tabs}StringToVector3((row.size() >= {i}+1) ? row[{i}].c_str() : nullptr, ctx->mutable_{self.to_message_field_name(column.name())}());\n'
            else:
                code = f'{tabs}// NOT IMPLEMENTED\n'

        return code 
